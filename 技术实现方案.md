# æŠ€æœ¯å®ç°æ–¹æ¡ˆ - Word Memo

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯
- **æ–‡æ¡£ç‰ˆæœ¬**: 1.0
- **åˆ›å»ºæ—¥æœŸ**: 2026-01-05
- **å¯¹åº”PRDç‰ˆæœ¬**: 1.0
- **ç›®æ ‡**: æŒ‡å¯¼å¼€å‘å›¢é˜Ÿå®ç°Word Memo V1.0

---

## ğŸ¯ æŠ€æœ¯æ¶æ„æ€»è§ˆ

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Edge Browser                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   Web Page (ä»»æ„ç½‘ç«™)                 â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  Content Script (æ³¨å…¥)                         â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - scanner.ts (é¡µé¢æ‰«æ)                       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - highlighter.ts (å•è¯é«˜äº®)                   â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  - viewport-tracker.ts (å¯è§†åŒºåŸŸè¿½è¸ª)          â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚                         â†•ï¸ (postMessage)              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                            â†•ï¸                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚         Background Service Worker                     â”‚   â”‚
â”‚  â”‚  - LLM APIè°ƒç”¨                                        â”‚   â”‚
â”‚  â”‚  - chrome.storageç®¡ç†                                â”‚   â”‚
â”‚  â”‚  - å®šæ—¶ä»»åŠ¡(é—å¿˜æ›²çº¿æ£€æŸ¥)                            â”‚   â”‚
â”‚  â”‚  - å³é”®èœå•æ³¨å†Œ                                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                            â†•ï¸                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Side Panel (ä¾§è¾¹æ UI)                    â”‚   â”‚
â”‚  â”‚  - React 18 + TypeScript                             â”‚   â”‚
â”‚  â”‚  - ZustandçŠ¶æ€ç®¡ç†                                    â”‚   â”‚
â”‚  â”‚  - Tailwind CSSæ ·å¼                                  â”‚   â”‚
â”‚  â”‚  - è™šæ‹Ÿæ»šåŠ¨(react-window)                            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                            â†•ï¸                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚           chrome.storage.local                        â”‚   â”‚
â”‚  â”‚  - vocabulary: Map<string, WordData>                 â”‚   â”‚
â”‚  â”‚  - settings: UserSettings                            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†•ï¸ HTTPS
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   OpenAI API (å…¼å®¹)      â”‚
              â”‚   - gpt-3.5-turbo        â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“¦ é¡¹ç›®ç»“æ„

```
word-memo/
â”œâ”€â”€ manifest.json                      # Extensioné…ç½®
â”œâ”€â”€ package.json                       # ä¾èµ–ç®¡ç†
â”œâ”€â”€ tsconfig.json                      # TSé…ç½®
â”œâ”€â”€ vite.config.ts                     # Viteæ„å»ºé…ç½®
â”œâ”€â”€ tailwind.config.js                 # Tailwindé…ç½®
â”œâ”€â”€ .env.example                       # ç¯å¢ƒå˜é‡ç¤ºä¾‹
â”‚
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ background/                    # Background Service Worker
â”‚   â”‚   â”œâ”€â”€ service-worker.ts          # ä¸»å…¥å£
â”‚   â”‚   â”œâ”€â”€ llm-client.ts              # LLM APIå®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ context-menu.ts            # å³é”®èœå•ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ message-handler.ts         # æ¶ˆæ¯è·¯ç”±
â”‚   â”‚   â””â”€â”€ alarm-handler.ts           # å®šæ—¶ä»»åŠ¡ï¼ˆé—å¿˜æ›²çº¿æ£€æŸ¥ï¼‰
â”‚   â”‚
â”‚   â”œâ”€â”€ content/                       # Content Script
â”‚   â”‚   â”œâ”€â”€ index.ts                   # ä¸»å…¥å£
â”‚   â”‚   â”œâ”€â”€ scanner.ts                 # é¡µé¢æ‰«æå™¨
â”‚   â”‚   â”œâ”€â”€ highlighter.ts             # å•è¯é«˜äº®æ¸²æŸ“
â”‚   â”‚   â”œâ”€â”€ viewport-tracker.ts        # å¯è§†åŒºåŸŸè¿½è¸ª
â”‚   â”‚   â”œâ”€â”€ message-bridge.ts          # ä¸Background/SidePanelé€šä¿¡
â”‚   â”‚   â””â”€â”€ styles.css                 # é«˜äº®æ ·å¼
â”‚   â”‚
â”‚   â”œâ”€â”€ sidepanel/                     # ä¾§è¾¹æ UI
â”‚   â”‚   â”œâ”€â”€ index.html                 # HTMLå…¥å£
â”‚   â”‚   â”œâ”€â”€ main.tsx                   # Reactå…¥å£
â”‚   â”‚   â”œâ”€â”€ App.tsx                    # ä¸»åº”ç”¨ç»„ä»¶
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ components/                # UIç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ WordList.tsx           # å•è¯åˆ—è¡¨ï¼ˆå½“å‰é¡µç”Ÿè¯ï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ WordCard.tsx           # å•è¯å¡ç‰‡
â”‚   â”‚   â”‚   â”œâ”€â”€ WordDetail.tsx         # å•è¯è¯¦æƒ…ï¼ˆç¼–è¾‘æ¨¡å¼ï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ VocabularyManagement.tsx # è¯åº“ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ PracticeMode.tsx       # ç»ƒä¹ æ¨¡å¼
â”‚   â”‚   â”‚   â””â”€â”€ Settings.tsx           # è®¾ç½®é¡µ
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ hooks/                     # Custom Hooks
â”‚   â”‚   â”‚   â”œâ”€â”€ useWordStore.ts        # è¯åº“çŠ¶æ€ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ useSettings.ts         # è®¾ç½®çŠ¶æ€ç®¡ç†
â”‚   â”‚   â”‚   â””â”€â”€ usePractice.ts         # ç»ƒä¹ æ¨¡å¼Hook
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ styles/                    # å…¨å±€æ ·å¼
â”‚   â”‚       â”œâ”€â”€ index.css              # Tailwindå…¥å£
â”‚   â”‚       â””â”€â”€ animations.css         # åŠ¨ç”»å®šä¹‰
â”‚   â”‚
â”‚   â”œâ”€â”€ lib/                           # å…±äº«å·¥å…·åº“
â”‚   â”‚   â”œâ”€â”€ storage.ts                 # chrome.storageæŠ½è±¡å±‚
â”‚   â”‚   â”œâ”€â”€ memory-algorithm.ts        # é—å¿˜æ›²çº¿ç®—æ³•
â”‚   â”‚   â”œâ”€â”€ word-normalizer.ts         # è¯å½¢è¿˜åŸ
â”‚   â”‚   â”œâ”€â”€ search.ts                  # æ¨¡ç³Šæœç´¢ï¼ˆFuse.jsï¼‰
â”‚   â”‚   â”œâ”€â”€ utils.ts                   # é€šç”¨å·¥å…·å‡½æ•°
â”‚   â”‚   â””â”€â”€ constants.ts               # å¸¸é‡å®šä¹‰
â”‚   â”‚
â”‚   â”œâ”€â”€ types/                         # TypeScriptç±»å‹å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ index.ts                   # æ ¸å¿ƒç±»å‹
â”‚   â”‚   â”œâ”€â”€ messages.ts                # æ¶ˆæ¯ç±»å‹
â”‚   â”‚   â””â”€â”€ storage.ts                 # å­˜å‚¨ç±»å‹
â”‚   â”‚
â”‚   â””â”€â”€ worker/                        # Web Worker
â”‚       â””â”€â”€ text-matcher.worker.ts     # æ–‡æœ¬åŒ¹é…Worker
â”‚
â”œâ”€â”€ public/                            # é™æ€èµ„æº
â”‚   â”œâ”€â”€ icons/                         # æ’ä»¶å›¾æ ‡
â”‚   â”‚   â”œâ”€â”€ icon16.png
â”‚   â”‚   â”œâ”€â”€ icon48.png
â”‚   â”‚   â””â”€â”€ icon128.png
â”‚   â””â”€â”€ _locales/                      # å›½é™…åŒ–ï¼ˆå¯é€‰ï¼‰
â”‚       â””â”€â”€ zh_CN/
â”‚           â””â”€â”€ messages.json
â”‚
â”œâ”€â”€ docs/                              # æ–‡æ¡£
â”‚   â”œâ”€â”€ PRD.md                         # äº§å“éœ€æ±‚æ–‡æ¡£
â”‚   â”œâ”€â”€ æŠ€æœ¯å®ç°æ–¹æ¡ˆ.md                # æœ¬æ–‡æ¡£
â”‚   â””â”€â”€ API.md                         # APIæ–‡æ¡£
â”‚
â””â”€â”€ tests/                             # æµ‹è¯•ï¼ˆå¯é€‰ï¼‰
    â”œâ”€â”€ unit/                          # å•å…ƒæµ‹è¯•
    â””â”€â”€ e2e/                           # E2Eæµ‹è¯•
```

---

## ğŸ”§ æ ¸å¿ƒæ¨¡å—å®ç°

### 1. Background Service Worker

#### 1.1 ä¸»å…¥å£ (service-worker.ts)

```typescript
// src/background/service-worker.ts

import { handleContextMenu } from './context-menu';
import { handleAlarm } from './alarm-handler';
import { handleMessage } from './message-handler';

// æ’ä»¶å®‰è£…/æ›´æ–°æ—¶åˆå§‹åŒ–
chrome.runtime.onInstalled.addListener(async (details) => {
  console.log('Word Memo installed:', details.reason);

  // æ³¨å†Œå³é”®èœå•
  chrome.contextMenus.create({
    id: 'add-to-vocabulary',
    title: 'ğŸ“š æ·»åŠ åˆ°è¯åº“',
    contexts: ['selection'],
  });

  // æ³¨å†Œå®šæ—¶ä»»åŠ¡ï¼ˆæ¯30åˆ†é’Ÿæ£€æŸ¥é—å¿˜æ›²çº¿ï¼‰
  chrome.alarms.create('checkMemoryDecay', {
    periodInMinutes: 30,
  });

  // åˆå§‹åŒ–é»˜è®¤è®¾ç½®
  const { settings } = await chrome.storage.local.get('settings');
  if (!settings) {
    await chrome.storage.local.set({
      settings: getDefaultSettings(),
    });
  }
});

// å³é”®èœå•ç‚¹å‡»å¤„ç†
chrome.contextMenus.onClicked.addListener(handleContextMenu);

// å®šæ—¶ä»»åŠ¡å¤„ç†
chrome.alarms.onAlarm.addListener(handleAlarm);

// æ¶ˆæ¯å¤„ç†ï¼ˆæ¥è‡ªContent Scriptæˆ–Side Panelï¼‰
chrome.runtime.onMessage.addListener(handleMessage);
```

#### 1.2 å³é”®èœå•å¤„ç† (context-menu.ts)

```typescript
// src/background/context-menu.ts

import { addWordToVocabulary } from '../lib/storage';
import { generateWordExplanation } from './llm-client';

export async function handleContextMenu(
  info: chrome.contextMenus.OnClickData,
  tab?: chrome.tabs.Tab
) {
  if (info.menuItemId !== 'add-to-vocabulary') return;

  const selectedText = info.selectionText?.trim();
  if (!selectedText || !tab?.id) return;

  // æ ‡å‡†åŒ–å•è¯ï¼ˆå°å†™ + å»é™¤ç‰¹æ®Šå­—ç¬¦ï¼‰
  const word = selectedText.toLowerCase().replace(/[^a-z-]/g, '');

  try {
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    const existing = await getWordFromVocabulary(word);
    if (existing) {
      chrome.tabs.sendMessage(tab.id, {
        type: 'WORD_ALREADY_EXISTS',
        payload: { word },
      });
      return;
    }

    // é€šçŸ¥Content Scriptæ˜¾ç¤ºloading
    chrome.tabs.sendMessage(tab.id, {
      type: 'WORD_ADDING',
      payload: { word },
    });

    // è°ƒç”¨LLMç”Ÿæˆé‡Šä¹‰
    const explanation = await generateWordExplanation(word);

    // ä¿å­˜åˆ°è¯åº“
    await addWordToVocabulary({
      word,
      ...explanation,
      memoryState: {
        level: MemoryLevel.NEW,
        reviewCount: 0,
        correctCount: 0,
        lastReviewDate: new Date(),
        nextReviewDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // 1å¤©å
        lastSeenDate: new Date(),
      },
      addedDate: new Date(),
      updatedDate: new Date(),
      source: tab.url,
    });

    // é€šçŸ¥Content Scriptå’ŒSide Panelæ›´æ–°
    chrome.tabs.sendMessage(tab.id, {
      type: 'WORD_ADDED',
      payload: { word },
    });

    chrome.runtime.sendMessage({
      type: 'VOCABULARY_UPDATED',
    });
  } catch (error) {
    console.error('Failed to add word:', error);

    chrome.tabs.sendMessage(tab.id, {
      type: 'WORD_ADD_FAILED',
      payload: {
        word,
        error: error.message,
      },
    });
  }
}
```

#### 1.3 LLMå®¢æˆ·ç«¯ (llm-client.ts)

```typescript
// src/background/llm-client.ts

import { getSettings } from '../lib/storage';

/**
 * LLMå“åº”æ¥å£
 */
interface LLMResponse {
  phonetic: string;
  definitions: Definition[];
  examples: Example[];
  etymology: string;
}

/**
 * ç”Ÿæˆå•è¯é‡Šä¹‰
 *
 * æ”¯æŒä»»ä½•OpenAI APIå…¼å®¹æ¥å£ï¼š
 * - OpenAIå®˜æ–¹ (api.openai.com)
 * - Azure OpenAI (*.openai.azure.com)
 * - å›½å†…å¤§æ¨¡å‹ï¼šæ™ºè°±AIã€ç™¾å·æ™ºèƒ½ã€DeepSeekã€Moonshotç­‰
 *
 * æ¨èæ¨¡å‹ï¼šgpt-3.5-turbo-0125ï¼ˆæ€§ä»·æ¯”æœ€ä¼˜ï¼Œå“åº”å¿«ï¼‰
 */
export async function generateWordExplanation(
  word: string
): Promise<LLMResponse> {
  const settings = await getSettings();
  const { llm } = settings;

  const systemPrompt = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„è‹±è¯­è¯æ±‡æ•™å­¦åŠ©æ‰‹ï¼Œä¸“æ³¨äºæŠ€æœ¯æ–‡æ¡£åœºæ™¯ã€‚è¯·ä¸ºç»™å®šå•è¯ç”Ÿæˆç»“æ„åŒ–é‡Šä¹‰ã€‚`;

  const userPrompt = `
è¯·ä¸ºå•è¯ "${word}" ç”Ÿæˆä»¥ä¸‹å†…å®¹ï¼Œä»¥JSONæ ¼å¼è¿”å›ï¼š

{
  "word": "å•è¯åŸæ–‡ï¼ˆå°å†™ï¼‰",
  "phonetic": "è‹±å¼éŸ³æ ‡ï¼ˆå¦‚ /ÉªËˆfem.É™r.É™l/ï¼‰",
  "definitions": [
    {
      "pos": "è¯æ€§ï¼ˆn./v./adj./adv.ç­‰ï¼‰",
      "meaning": "ä¸­æ–‡é‡Šä¹‰ï¼ˆç®€æ´ï¼Œ15å­—ä»¥å†…ï¼‰"
    }
  ],
  "examples": [
    {
      "en": "è‹±æ–‡ä¾‹å¥ï¼ˆä¼˜å…ˆæŠ€æœ¯åœºæ™¯ï¼‰",
      "zh": "ä¸­æ–‡ç¿»è¯‘"
    }
  ],
  "etymology": "è¯æ ¹è¯ç¼€è§£é‡Šã€‚å¦‚æ— æ˜ç¡®è¯æ ¹ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²ã€‚"
}

è¦æ±‚ï¼š
1. definitionsæ•°ç»„åŒ…å«æ‰€æœ‰å¸¸è§è¯æ€§å’Œé‡Šä¹‰ï¼ˆæœ€å¤š3ä¸ªï¼‰
2. examplesæ•°ç»„åŒ…å«2-3ä¸ªä¾‹å¥ï¼Œä¼˜å…ˆä½¿ç”¨ç¼–ç¨‹/æŠ€æœ¯ç›¸å…³ä¾‹å¥
3. é‡Šä¹‰ç®€æ´ä¸“ä¸šï¼Œé¿å…å†—é•¿è§£é‡Š
4. ä¾‹å¥éš¾åº¦é€‚ä¸­ï¼Œè´´è¿‘å®é™…ä½¿ç”¨åœºæ™¯
`;

  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), llm.timeout);

  try {
    const response = await fetch(llm.apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${llm.apiKey}`,
      },
      body: JSON.stringify({
        model: llm.model,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
        temperature: llm.temperature,
        response_format: { type: 'json_object' }, // å¼ºåˆ¶JSONè¾“å‡º
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error?.message || response.statusText);
    }

    const data = await response.json();
    const content = data.choices[0].message.content;
    const parsed = JSON.parse(content);

    // éªŒè¯å“åº”æ ¼å¼
    if (!parsed.phonetic || !parsed.definitions || !parsed.examples) {
      throw new Error('å“åº”æ ¼å¼é”™è¯¯');
    }

    return parsed;
  } catch (error) {
    if (error.name === 'AbortError') {
      throw new Error('è¯·æ±‚è¶…æ—¶ï¼ˆ30sï¼‰');
    }
    throw error;
  }
}

export async function testLLMConnection(): Promise<{
  success: boolean;
  message: string;
}> {
  try {
    await generateWordExplanation('test');
    return { success: true, message: 'âœ… è¿æ¥æˆåŠŸï¼' };
  } catch (error) {
    return { success: false, message: `âŒ ${error.message}` };
  }
}

/**
 * ç”Ÿæˆç»ƒä¹ é¢˜ç›®
 */
export async function generatePracticeQuestion(
  word: string,
  wordData: {
    definitions: { pos: string; meaning: string }[];
    examples: { en: string; zh: string }[];
  },
  type: 'choice'
): Promise<PracticeQuestion> {
  const settings = await getSettings();
  const { llm } = settings;

  const definitionsText = wordData.definitions
    .map(d => `${d.pos}. ${d.meaning}`)
    .join('\n');

  const examplesText = wordData.examples
    .map(e => `â€¢ ${e.en}\n  ${e.zh}`)
    .join('\n');

  const userPrompt = `
è¯·ä¸ºå•è¯ "${word}" ç”Ÿæˆä¸€é“é€‰æ‹©é¢˜ã€‚

å•è¯é‡Šä¹‰ï¼š
${definitionsText}

ä¾‹å¥ï¼š
${examplesText}

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼š
{
  "question": "é¢˜å¹²æè¿°ä¸€ä¸ªåœºæ™¯ï¼Œè®©ç”¨æˆ·é€‰æ‹©æœ€åˆé€‚çš„å•è¯ç”¨æ³•",
  "options": ["é€‰é¡¹A", "é€‰é¡¹B", "é€‰é¡¹C", "é€‰é¡¹D"],
  "correctAnswer": "æ­£ç¡®é€‰é¡¹ï¼ˆå®Œæ•´æ–‡æœ¬ï¼‰",
  "explanation": "ç­”æ¡ˆè§£æï¼Œè¯´æ˜ä¸ºä»€ä¹ˆæ­£ç¡®é€‰é¡¹æœ€åˆé€‚"
}`;

  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), llm.timeout);

  try {
    const response = await fetch(llm.apiEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${llm.apiKey}`,
      },
      body: JSON.stringify({
        model: llm.model,
        messages: [
          {
            role: 'system',
            content: 'ä½ æ˜¯ä¸€ä¸ªè‹±è¯­è¯æ±‡æ•™å­¦åŠ©æ‰‹ï¼Œä¸“æ³¨äºç”Ÿæˆé«˜è´¨é‡çš„é€‰æ‹©é¢˜ã€‚',
          },
          { role: 'user', content: userPrompt },
        ],
        temperature: 0.7,
        response_format: { type: 'json_object' },
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error?.message || response.statusText);
    }

    const data = await response.json();
    const content = data.choices[0].message.content;
    const parsed = JSON.parse(content);

    return {
      id: `${word}-${Date.now()}`,
      word,
      type,
      question: parsed.question,
      options: parsed.options,
      correctAnswer: parsed.correctAnswer,
      explanation: parsed.explanation,
    };
  } catch (error) {
    if (error.name === 'AbortError') {
      throw new Error('è¯·æ±‚è¶…æ—¶ï¼ˆ30sï¼‰');
    }
    throw error;
  }
}
```

#### 1.4 å®šæ—¶ä»»åŠ¡å¤„ç† (alarm-handler.ts)

```typescript
// src/background/alarm-handler.ts

import { getVocabulary, saveWord } from '../lib/storage';
import { shouldDowngrade, downgradeLevel, calculateNextReview } from '../lib/memory-algorithm';

export async function handleAlarm(alarm: chrome.alarms.Alarm) {
  if (alarm.name !== 'checkMemoryDecay') return;

  console.log('Checking memory decay...');

  const vocabulary = await getVocabulary();
  const updatedWords: string[] = [];

  for (const [word, data] of vocabulary.entries()) {
    if (shouldDowngrade(data.memoryState)) {
      data.memoryState.level = downgradeLevel(data.memoryState.level);
      data.memoryState.nextReviewDate = calculateNextReview(
        data.memoryState.level,
        false
      );
      data.updatedDate = new Date();

      await saveWord(data);
      updatedWords.push(word);
    }
  }

  if (updatedWords.length > 0) {
    console.log(`Downgraded ${updatedWords.length} words:`, updatedWords);

    // é€šçŸ¥Side Panelæ›´æ–°UI
    chrome.runtime.sendMessage({
      type: 'VOCABULARY_UPDATED',
      payload: { updatedWords },
    });
  }
}
```

---

### 2. Content Script

#### 2.1 ä¸»å…¥å£ (content/index.ts)

```typescript
// src/content/index.ts

import { VocabularyScanner } from './scanner';
import { WordHighlighter } from './highlighter';
import { ViewportTracker } from './viewport-tracker';
import { MessageBridge } from './message-bridge';

class ContentScriptApp {
  private scanner: VocabularyScanner;
  private highlighter: WordHighlighter;
  private viewportTracker: ViewportTracker;
  private messageBridge: MessageBridge;

  async init() {
    // åˆå§‹åŒ–å„æ¨¡å—
    this.scanner = new VocabularyScanner();
    this.highlighter = new WordHighlighter();
    this.viewportTracker = new ViewportTracker();
    this.messageBridge = new MessageBridge();

    // åŠ è½½è¯åº“
    await this.scanner.init();

    // ç›‘å¬å¯è§†åŒºåŸŸå˜åŒ–
    this.viewportTracker.on('viewportChanged', (visibleWords) => {
      this.messageBridge.sendToSidePanel({
        type: 'VISIBLE_WORDS_UPDATED',
        payload: { words: visibleWords },
      });
    });

    // ç›‘å¬Backgroundæ¶ˆæ¯
    this.messageBridge.on('WORD_ADDED', ({ word }) => {
      this.scanner.addWord(word);
      this.highlighter.highlightWord(word);
    });

    this.messageBridge.on('WORD_DELETED', ({ word }) => {
      this.scanner.removeWord(word);
      this.highlighter.removeHighlight(word);
    });

    this.messageBridge.on('VOCABULARY_UPDATED', async () => {
      await this.scanner.reload();
      this.highlighter.rerender();
    });

    // æ‰§è¡Œé¦–æ¬¡æ‰«æ
    this.scanner.scanViewport();
  }
}

// å¯åŠ¨
const app = new ContentScriptApp();
app.init();
```

#### 2.2 é¡µé¢æ‰«æå™¨ (scanner.ts)

```typescript
// src/content/scanner.ts

import { getVocabulary } from '../lib/storage';
import { normalizeWord } from '../lib/word-normalizer';
import { debounce } from '../lib/utils';

export class VocabularyScanner {
  private vocabulary: Set<string>; // è¯åº“å•è¯é›†åˆï¼ˆå°å†™ï¼‰
  private visibleWords: Map<string, Element[]>; // å¯è§†åŒºåŸŸå†…çš„å•è¯å…ƒç´ 
  private observer: MutationObserver;

  async init() {
    // åŠ è½½è¯åº“
    const vocab = await getVocabulary();
    this.vocabulary = new Set(vocab.keys());

    // ç›‘å¬æ»šåŠ¨ï¼ˆDebounce 200msï¼‰
    window.addEventListener('scroll', debounce(() => this.scanViewport(), 200), {
      passive: true,
    });

    // ç›‘å¬DOMå˜åŒ–
    this.observer = new MutationObserver(() => this.scanViewport());
    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
    });
  }

  scanViewport() {
    const viewportTop = window.scrollY;
    const viewportBottom = viewportTop + window.innerHeight;

    // æ‰«æèŒƒå›´ï¼šå¯è§†åŒºåŸŸ +/- 1å±
    const scanTop = Math.max(0, viewportTop - window.innerHeight);
    const scanBottom = viewportBottom + window.innerHeight;

    const textNodes = this.getTextNodesInRange(scanTop, scanBottom);
    const matches = this.matchWords(textNodes);

    // æ¸²æŸ“é«˜äº®
    this.highlighter.highlightMatches(matches);

    // æå–å¯è§†åŒºåŸŸå†…çš„å•è¯
    const visibleWords = matches
      .filter((m) => {
        const rect = m.element.getBoundingClientRect();
        return rect.top < window.innerHeight && rect.bottom > 0;
      })
      .map((m) => m.normalizedWord);

    // é€šçŸ¥Side Panel
    this.viewportTracker.emit('viewportChanged', Array.from(new Set(visibleWords)));
  }

  private getTextNodesInRange(top: number, bottom: number): Node[] {
    const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, {
      acceptNode: (node) => {
        const parent = node.parentElement;
        if (!parent) return NodeFilter.FILTER_REJECT;

        // è¿‡æ»¤scriptã€styleã€codeã€preæ ‡ç­¾
        if (
          ['SCRIPT', 'STYLE', 'NOSCRIPT'].includes(parent.tagName) ||
          parent.closest('code, pre')
        ) {
          return NodeFilter.FILTER_REJECT;
        }

        // æ£€æŸ¥æ˜¯å¦åœ¨æ‰«æèŒƒå›´å†…
        const rect = parent.getBoundingClientRect();
        const elementTop = rect.top + window.scrollY;
        const elementBottom = elementTop + rect.height;

        if (elementBottom < top || elementTop > bottom) {
          return NodeFilter.FILTER_REJECT;
        }

        return NodeFilter.FILTER_ACCEPT;
      },
    });

    const nodes: Node[] = [];
    let currentNode;
    while ((currentNode = walker.nextNode())) {
      nodes.push(currentNode);
    }
    return nodes;
  }

  private matchWords(textNodes: Node[]): MatchResult[] {
    const matches: MatchResult[] = [];

    textNodes.forEach((node) => {
      const text = node.textContent || '';
      const wordRegex = /\b[a-zA-Z]+(?:-[a-zA-Z]+)*\b/g;
      let match;

      while ((match = wordRegex.exec(text)) !== null) {
        const originalWord = match[0];
        const normalizedWord = normalizeWord(originalWord);

        if (this.vocabulary.has(normalizedWord)) {
          matches.push({
            word: originalWord,
            normalizedWord,
            element: node,
            offset: match.index,
            length: originalWord.length,
          });
        }
      }
    });

    return matches;
  }
}
```

#### 2.3 å•è¯é«˜äº® (highlighter.ts)

```typescript
// src/content/highlighter.ts

export class WordHighlighter {
  highlightMatches(matches: MatchResult[]) {
    // æŒ‰æ–‡æœ¬èŠ‚ç‚¹åˆ†ç»„
    const grouped = this.groupBy(matches, (m) => m.element);

    grouped.forEach((nodeMatches, textNode) => {
      // ä»åå¾€å‰æ›¿æ¢ï¼ˆé¿å…åç§»é‡å˜åŒ–ï¼‰
      nodeMatches.sort((a, b) => b.offset - a.offset);

      nodeMatches.forEach((match) => {
        const wordData = getWordFromVocabulary(match.normalizedWord);
        const level = wordData.memoryState.level;

        // åˆ›å»ºé«˜äº®å…ƒç´ 
        const span = document.createElement('span');
        span.className = `word-memo-highlight word-memo-level-${level}`;
        span.dataset.word = match.normalizedWord;
        span.textContent = match.word;

        // ç‚¹å‡»äº‹ä»¶ï¼šæ»šåŠ¨ä¾§è¾¹æ å®šä½
        span.addEventListener('click', (e) => {
          e.preventDefault();
          chrome.runtime.sendMessage({
            type: 'SCROLL_TO_CARD',
            payload: { word: match.normalizedWord },
          });
        });

        // æ›¿æ¢æ–‡æœ¬èŠ‚ç‚¹
        const text = textNode.textContent || '';
        const before = text.substring(0, match.offset);
        const after = text.substring(match.offset + match.length);

        const fragment = document.createDocumentFragment();
        fragment.appendChild(document.createTextNode(before));
        fragment.appendChild(span);
        fragment.appendChild(document.createTextNode(after));

        textNode.parentNode?.replaceChild(fragment, textNode);
      });
    });
  }

  private groupBy<T, K>(items: T[], keyFn: (item: T) => K): Map<K, T[]> {
    const map = new Map<K, T[]>();
    items.forEach((item) => {
      const key = keyFn(item);
      if (!map.has(key)) map.set(key, []);
      map.get(key)!.push(item);
    });
    return map;
  }
}
```

---

### 3. Side Panel (ä¾§è¾¹æ UI)

#### 3.1 ä¸»åº”ç”¨ (App.tsx)

```typescript
// src/sidepanel/App.tsx

import { useState } from 'react';
import { Header } from './components/Header';
import { TabBar } from './components/TabBar';
import { VirtualWordList } from './components/VirtualWordList';
import { VocabBrowser } from './components/VocabBrowser';
import { Settings } from './components/Settings';
import { ResizablePanel } from './components/ResizablePanel';
import { useWordStore } from './hooks/useWordStore';
import { useSettings } from './hooks/useSettings';

type TabType = 'current-page' | 'vocabulary';

export function App() {
  const [activeTab, setActiveTab] = useState<TabType>('current-page');
  const [showSettings, setShowSettings] = useState(false);
  const [collapsed, setCollapsed] = useState(false);

  const { visibleWords, allWords, highlightedWord } = useWordStore();
  const { settings } = useSettings();

  const displayedWords = activeTab === 'current-page' ? visibleWords : allWords;

  if (showSettings) {
    return <Settings onClose={() => setShowSettings(false)} />;
  }

  return (
    <ResizablePanel>
      <div className={`sidebar ${collapsed ? 'collapsed' : ''}`}>
        <Header
          onSettingsClick={() => setShowSettings(true)}
          onToggleCollapse={() => setCollapsed(!collapsed)}
          collapsed={collapsed}
        />

        {!collapsed && (
          <>
            <TabBar activeTab={activeTab} onTabChange={setActiveTab} />

            {activeTab === 'current-page' ? (
              <VirtualWordList
                words={displayedWords}
                highlightedWord={highlightedWord}
              />
            ) : (
              <VocabBrowser words={allWords} />
            )}
          </>
        )}
      </div>
    </ResizablePanel>
  );
}
```

#### 3.2 å•è¯å¡ç‰‡ (WordCard.tsx)

```typescript
// src/sidepanel/components/WordCard.tsx

import { useState } from 'react';
import { WordData } from '../../types';
import { handleRemembered, handleNotRemembered } from '../../lib/memory-algorithm';

interface WordCardProps {
  word: WordData;
  highlighted?: boolean;
}

export function WordCard({ word, highlighted }: WordCardProps) {
  const [expanded, setExpanded] = useState(word.memoryState.level === MemoryLevel.NEW);

  const levelColors = {
    [MemoryLevel.NEW]: 'border-red-500 bg-red-50',
    [MemoryLevel.FAMILIAR]: 'border-orange-500 bg-orange-50',
    [MemoryLevel.LEARNING]: 'border-yellow-500 bg-yellow-50',
    [MemoryLevel.MASTERED]: 'border-green-500 bg-green-50',
  };

  return (
    <div
      className={`
        word-card
        ${levelColors[word.memoryState.level]}
        ${highlighted ? 'word-card-highlighted' : ''}
        transition-all duration-300
      `}
      onMouseEnter={() => setExpanded(true)}
      onMouseLeave={() => {
        if (word.memoryState.level !== MemoryLevel.NEW) {
          setExpanded(false);
        }
      }}
    >
      {/* Header */}
      <div className="flex justify-between items-center mb-2">
        <h3 className="text-lg font-bold">{word.word}</h3>
        <div className="flex gap-2">
          <button onClick={() => pronounce(word.word)}>ğŸ”Š</button>
          <button onClick={() => editWord(word)}>âœï¸</button>
          <button onClick={() => deleteWord(word)}>ğŸ—‘ï¸</button>
        </div>
      </div>

      {/* Phonetic */}
      <p className="text-sm text-gray-600 mb-2">{word.phonetic}</p>

      {/* Definitions */}
      <div className="mb-2">
        {word.definitions.map((def, i) => (
          <div key={i} className="text-sm">
            <span className="font-semibold">{def.pos}</span> {def.meaning}
          </div>
        ))}
      </div>

      {/* Examples (å¯æŠ˜å ) */}
      {expanded && (
        <>
          <div className="mt-3 border-t pt-2">
            {word.examples.map((ex, i) => (
              <div key={i} className="mb-2 text-sm">
                <p className="italic text-gray-700">{ex.en}</p>
                <p className="text-gray-600">{ex.zh}</p>
              </div>
            ))}
          </div>

          {word.etymology && (
            <div className="mt-2 text-xs text-gray-500">
              <strong>è¯æ ¹:</strong> {word.etymology}
            </div>
          )}
        </>
      )}

      {/* Memory Feedback */}
      <div className="mt-3 border-t pt-2">
        <p className="text-sm mb-2">â“ æ˜¯å¦è®°ä½äº†è¿™ä¸ªå•è¯ï¼Ÿ</p>
        <div className="flex gap-2">
          <button
            className="btn-remembered flex-1 bg-green-500 text-white px-3 py-1 rounded"
            onClick={() => handleRemembered(word)}
          >
            è®°ä½äº† âœ“
          </button>
          <button
            className="btn-not-remembered flex-1 bg-orange-500 text-white px-3 py-1 rounded"
            onClick={() => handleNotRemembered(word)}
          >
            è¿˜ä¸ç†Ÿ Ã—
          </button>
        </div>
      </div>
    </div>
  );
}
```

#### 3.3 è™šæ‹Ÿæ»šåŠ¨åˆ—è¡¨ (VirtualWordList.tsx)

```typescript
// src/sidepanel/components/VirtualWordList.tsx

import { useRef, useEffect } from 'react';
import { FixedSizeList as List } from 'react-window';
import { WordCard } from './WordCard';

interface VirtualWordListProps {
  words: WordData[];
  highlightedWord?: string;
}

export function VirtualWordList({ words, highlightedWord }: VirtualWordListProps) {
  const listRef = useRef<List>(null);

  // æ’åºï¼šè®°å¿†ç­‰çº§ä½çš„æ’å‰é¢
  const sortedWords = [...words].sort((a, b) => {
    return a.memoryState.level - b.memoryState.level;
  });

  // æ»šåŠ¨åˆ°é«˜äº®å•è¯
  useEffect(() => {
    if (highlightedWord) {
      const index = sortedWords.findIndex((w) => w.word === highlightedWord);
      if (index >= 0) {
        listRef.current?.scrollToItem(index, 'center');
      }
    }
  }, [highlightedWord, sortedWords]);

  return (
    <List
      ref={listRef}
      height={600}
      itemCount={sortedWords.length}
      itemSize={120} // å¹³å‡é«˜åº¦
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>
          <WordCard
            word={sortedWords[index]}
            highlighted={sortedWords[index].word === highlightedWord}
          />
        </div>
      )}
    </List>
  );
}
```

---

### 4. å…±äº«å·¥å…·åº“

#### 4.1 é—å¿˜æ›²çº¿ç®—æ³• (lib/memory-algorithm.ts)

```typescript
// src/lib/memory-algorithm.ts

import { MemoryLevel, WordMemoryState } from '../types';

/**
 * è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
 */
export function calculateNextReview(level: MemoryLevel, isRemembered: boolean): Date {
  const intervals: Record<MemoryLevel, { yes: number; no: number }> = {
    [MemoryLevel.NEW]: { yes: 1, no: 0.5 },
    [MemoryLevel.FAMILIAR]: { yes: 3, no: 1 },
    [MemoryLevel.LEARNING]: { yes: 7, no: 3 },
    [MemoryLevel.MASTERED]: { yes: 30, no: 7 },
    [MemoryLevel.ARCHIVED]: { yes: 90, no: 30 },
  };

  const days = isRemembered ? intervals[level].yes : intervals[level].no;
  return new Date(Date.now() + days * 24 * 60 * 60 * 1000);
}

/**
 * å‡çº§è®°å¿†ç­‰çº§
 */
export function upgradeLevel(currentLevel: MemoryLevel): MemoryLevel {
  if (currentLevel >= MemoryLevel.ARCHIVED) return MemoryLevel.ARCHIVED;
  return currentLevel + 1;
}

/**
 * é™çº§è®°å¿†ç­‰çº§
 */
export function downgradeLevel(currentLevel: MemoryLevel): MemoryLevel {
  if (currentLevel <= MemoryLevel.NEW) return MemoryLevel.NEW;
  return currentLevel - 1;
}

/**
 * æ£€æŸ¥æ˜¯å¦éœ€è¦é™çº§ï¼ˆè¶…è¿‡å¤ä¹ æ—¶é—´çš„1.5å€ï¼‰
 */
export function shouldDowngrade(state: WordMemoryState): boolean {
  const now = Date.now();
  const nextReview = state.nextReviewDate.getTime();
  const overdueThreshold = 1.5;

  return now > nextReview * overdueThreshold;
}

/**
 * ç”¨æˆ·ç‚¹å‡»"è®°ä½äº†"
 */
export async function handleRemembered(word: WordData) {
  word.memoryState.correctCount++;
  word.memoryState.reviewCount++;
  word.memoryState.level = upgradeLevel(word.memoryState.level);
  word.memoryState.lastReviewDate = new Date();
  word.memoryState.nextReviewDate = calculateNextReview(word.memoryState.level, true);
  word.updatedDate = new Date();

  await saveWord(word);

  // è§¦å‘UIæ›´æ–°
  chrome.runtime.sendMessage({ type: 'VOCABULARY_UPDATED' });
}

/**
 * ç”¨æˆ·ç‚¹å‡»"è¿˜ä¸ç†Ÿ"
 */
export async function handleNotRemembered(word: WordData) {
  word.memoryState.reviewCount++;
  word.memoryState.lastReviewDate = new Date();
  word.memoryState.nextReviewDate = calculateNextReview(word.memoryState.level, false);
  word.updatedDate = new Date();

  await saveWord(word);

  chrome.runtime.sendMessage({ type: 'VOCABULARY_UPDATED' });
}
```

#### 4.2 ç»ƒä¹ æ¨¡å¼åŠŸèƒ½ (lib/memory-algorithm.ts)

```typescript
// src/lib/memory-algorithm.ts

const MAX_PRACTICE_WORDS = 5;
const EXPIRING_HOURS_THRESHOLD = 24;

/**
 * ä¸ºç»ƒä¹ é€‰æ‹©å•è¯ï¼ˆæœ€å¤š5ä¸ªï¼‰
 * ä¼˜å…ˆçº§ï¼š
 * 1. å·²è¿‡æœŸå•è¯ï¼ˆä¼˜å…ˆæœ€ä¹…æ²¡å¤ä¹ çš„ï¼‰
 * 2. 24å°æ—¶å†…å³å°†è¿‡æœŸå•è¯
 * 3. æ­£å¸¸å¤ä¹ æœŸå†…å•è¯
 * 4. æ–°è¯ä¼˜å…ˆ
 */
export function selectWordsForPractice(vocabulary: WordData[]): WordData[] {
  const now = Date.now();

  const candidates = vocabulary
    .filter(w => w.memoryState.level < MemoryLevel.ARCHIVED)
    .map(w => {
      const nextReview = new Date(w.memoryState.nextReviewDate).getTime();
      const overdueHours = (now - nextReview) / (1000 * 60 * 60);

      let priority: number;
      if (overdueHours > 0) {
        priority = 0; // å·²è¿‡æœŸ
      } else if (overdueHours > -EXPIRING_HOURS_THRESHOLD) {
        priority = 1; // 24å°æ—¶å†…åˆ°æœŸ
      } else {
        priority = 2; // æ­£å¸¸å¤ä¹ æœŸ
      }

      // æ–°è¯ï¼ˆä»æœªå¤ä¹ ï¼‰åœ¨åŒç»„ä¸­ä¼˜å…ˆ
      if (w.memoryState.reviewCount === 0) {
        priority -= 0.5;
      }

      return { word: w.word, data: w, priority, overdueHours };
    });

  // æŒ‰ä¼˜å…ˆçº§æ’åº
  candidates.sort((a, b) => {
    if (a.priority !== b.priority) return a.priority - b.priority;
    return a.overdueHours - b.overdueHours;
  });

  return candidates.slice(0, MAX_PRACTICE_WORDS).map(c => c.data);
}

/**
 * æ£€æŸ¥å•è¯æ˜¯å¦å·²è¿‡æœŸï¼ˆå¯ä»¥å‡çº§ï¼‰
 */
export function isWordExpired(word: WordData): boolean {
  const now = Date.now();
  const nextReview = new Date(word.memoryState.nextReviewDate).getTime();
  return now > nextReview;
}

/**
 * ç»ƒä¹ ç­”é¢˜åæ›´æ–°å•è¯çŠ¶æ€
 */
export async function updateWordAfterPractice(
  word: WordData,
  isCorrect: boolean
): Promise<void> {
  word.memoryState.reviewCount++;

  if (isCorrect) {
    word.memoryState.correctCount++;
    // åªæœ‰å·²è¿‡æœŸæ‰å‡çº§
    if (isWordExpired(word)) {
      word.memoryState.level = upgradeLevel(word.memoryState.level);
    }
  } else {
    // ç­”é”™é™çº§
    word.memoryState.level = downgradeLevel(word.memoryState.level);
  }

  word.memoryState.lastReviewDate = new Date();
  word.memoryState.nextReviewDate = calculateNextReview(
    word.memoryState.level,
    isCorrect
  );
  word.updatedDate = new Date();

  await saveWord(word);
  chrome.runtime.sendMessage({ type: 'VOCABULARY_UPDATED' });
}
```

#### 4.3 è¯å½¢è¿˜åŸ (lib/word-normalizer.ts)

```typescript
// src/lib/word-normalizer.ts

import nlp from 'compromise';

/**
 * å•è¯æ ‡å‡†åŒ–ï¼ˆå°å†™ + è¯å½¢è¿˜åŸï¼‰
 */
export function normalizeWord(word: string): string {
  const lowercased = word.toLowerCase();

  // ä½¿ç”¨compromise.jsè¿›è¡Œè¯å½¢è¿˜åŸ
  const doc = nlp(lowercased);

  // å°è¯•è¿˜åŸåŠ¨è¯
  const verb = doc.verbs().toInfinitive().text();
  if (verb) return verb;

  // å°è¯•è¿˜åŸåè¯
  const noun = doc.nouns().toSingular().text();
  if (noun) return noun;

  // æ— æ³•è¿˜åŸï¼Œè¿”å›å°å†™
  return lowercased;
}
```

#### 4.3 å­˜å‚¨æŠ½è±¡å±‚ (lib/storage.ts)

```typescript
// src/lib/storage.ts

import { WordData, UserSettings } from '../types';

enum StorageKey {
  VOCABULARY = 'vocabulary',
  SETTINGS = 'settings',
}

/**
 * è·å–è¯åº“
 */
export async function getVocabulary(): Promise<Map<string, WordData>> {
  const result = await chrome.storage.local.get(StorageKey.VOCABULARY);
  const data = result[StorageKey.VOCABULARY] || {};
  return new Map(Object.entries(data));
}

/**
 * ä¿å­˜å•è¯
 */
export async function saveWord(word: WordData): Promise<void> {
  const vocabulary = await getVocabulary();
  vocabulary.set(word.word, word);

  await chrome.storage.local.set({
    [StorageKey.VOCABULARY]: Object.fromEntries(vocabulary),
  });
}

/**
 * åˆ é™¤å•è¯
 */
export async function deleteWord(word: string): Promise<void> {
  const vocabulary = await getVocabulary();
  vocabulary.delete(word);

  await chrome.storage.local.set({
    [StorageKey.VOCABULARY]: Object.fromEntries(vocabulary),
  });
}

/**
 * è·å–å•ä¸ªå•è¯
 */
export async function getWordFromVocabulary(word: string): Promise<WordData | null> {
  const vocabulary = await getVocabulary();
  return vocabulary.get(word) || null;
}

/**
 * è·å–è®¾ç½®
 */
export async function getSettings(): Promise<UserSettings> {
  const result = await chrome.storage.local.get(StorageKey.SETTINGS);
  return result[StorageKey.SETTINGS] || getDefaultSettings();
}

/**
 * ä¿å­˜è®¾ç½®
 */
export async function saveSettings(settings: UserSettings): Promise<void> {
  await chrome.storage.local.set({ [StorageKey.SETTINGS]: settings });
}

/**
 * é»˜è®¤è®¾ç½®
 */
export function getDefaultSettings(): UserSettings {
  return {
    llm: {
      apiEndpoint: 'https://api.openai.com/v1/chat/completions',
      apiKey: '',
      model: 'gpt-3.5-turbo-0125', // æ¨èæ¨¡å‹ï¼Œæ€§ä»·æ¯”æœ€ä¼˜
      temperature: 0.3,
      timeout: 30000,
    },
    display: {
      enableHighlight: true,
      ignoreCodeBlocks: true,
      showReviewReminder: true,
      autoPlayPronunciation: false,
    },
    sidebar: {
      width: 400,
      collapsed: false,
    },
  };
}

// ==================== ç»ƒä¹ ç¼“å­˜ ====================

const PRACTICE_CACHE_KEY = 'practiceCache';
const PRACTICE_CACHE_DURATION = 24 * 60 * 60 * 1000; // 24å°æ—¶

interface PracticeQuestionCache {
  [word: string]: {
    question: PracticeQuestion;
    timestamp: number;
  };
}

/**
 * ä¿å­˜ç»ƒä¹ é¢˜ç›®åˆ°ç¼“å­˜
 */
export async function savePracticeQuestion(
  word: string,
  question: PracticeQuestion
): Promise<void> {
  const cache = await getPracticeCache();
  cache[word] = {
    question,
    timestamp: Date.now(),
  };
  await chrome.storage.local.set({ [PRACTICE_CACHE_KEY]: cache });
}

/**
 * è·å–ç»ƒä¹ ç¼“å­˜
 */
export async function getPracticeCache(): Promise<PracticeQuestionCache> {
  const result = await chrome.storage.local.get(PRACTICE_CACHE_KEY);
  return result[PRACTICE_CACHE_KEY] || {};
}

/**
 * è·å–å•è¯çš„ç»ƒä¹ é¢˜ç¼“å­˜ï¼ˆæ£€æŸ¥æ˜¯å¦è¿‡æœŸï¼‰
 */
export async function getPracticeQuestionsForWord(
  word: string
): Promise<PracticeQuestion | null> {
  const cache = await getPracticeCache();
  const cached = cache[word];

  if (!cached) return null;

  // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
  if (Date.now() - cached.timestamp > PRACTICE_CACHE_DURATION) {
    return null;
  }

  return cached.question;
}
```

---

## ğŸ”¨ æ„å»ºé…ç½®

### Viteé…ç½® (vite.config.ts)

```typescript
// vite.config.ts

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
  plugins: [react()],
  build: {
    rollupOptions: {
      input: {
        sidepanel: resolve(__dirname, 'src/sidepanel/index.html'),
        background: resolve(__dirname, 'src/background/service-worker.ts'),
        content: resolve(__dirname, 'src/content/index.ts'),
      },
      output: {
        entryFileNames: '[name].js',
        chunkFileNames: '[name].js',
        assetFileNames: '[name].[ext]',
      },
    },
    outDir: 'dist',
  },
});
```

### Manifest V3é…ç½® (manifest.json)

```json
{
  "manifest_version": 3,
  "name": "Word Memo - è¯æ±‡è®°å¿†åŠ©æ‰‹",
  "version": "1.0.0",
  "description": "éä¾µå…¥å¼è‹±æ–‡é˜…è¯»è¾…åŠ©ä¸AIé©±åŠ¨çš„è¯æ±‡è®°å¿†ç®¡ç†å·¥å…·",
  "permissions": ["storage", "contextMenus", "sidePanel", "alarms"],
  "host_permissions": ["https://*/*"],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"],
      "css": ["content.css"],
      "run_at": "document_idle"
    }
  ],
  "side_panel": {
    "default_path": "sidepanel.html"
  },
  "action": {
    "default_icon": "icons/icon48.png",
    "default_title": "æ‰“å¼€Word Memo"
  },
  "icons": {
    "16": "icons/icon16.png",
    "48": "icons/icon48.png",
    "128": "icons/icon128.png"
  }
}
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•
- é—å¿˜æ›²çº¿ç®—æ³•ï¼ˆ`memory-algorithm.ts`ï¼‰
- è¯å½¢è¿˜åŸï¼ˆ`word-normalizer.ts`ï¼‰
- å­˜å‚¨æŠ½è±¡å±‚ï¼ˆ`storage.ts`ï¼‰

### é›†æˆæµ‹è¯•
- LLM APIè°ƒç”¨
- chrome.storageè¯»å†™
- æ¶ˆæ¯ä¼ é€’æœºåˆ¶

### E2Eæµ‹è¯•ï¼ˆå¯é€‰ï¼‰
- å®Œæ•´ç”¨æˆ·æµç¨‹ï¼šæ·»åŠ å•è¯ â†’ å¤ä¹  â†’ é—å¿˜é™çº§

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–æ¸…å•

- âœ… Web Workerå¤„ç†æ–‡æœ¬åŒ¹é…
- âœ… Debounceæ»šåŠ¨äº‹ä»¶ï¼ˆ200msï¼‰
- âœ… è™šæ‹Ÿæ»šåŠ¨ï¼ˆreact-windowï¼‰
- âœ… IntersectionObserverç›‘å¬å¯è§æ€§
- âœ… RequestIdleCallbackç©ºé—²æ—¶é¢„åŠ è½½
- âœ… è¯åº“å•è¯ç´¢å¼•ï¼ˆSetæŸ¥æ‰¾ O(1)ï¼‰

---

## ğŸš€ éƒ¨ç½²æµç¨‹

### æœ¬åœ°å¼€å‘
```bash
npm install
npm run dev       # å¼€å‘æ¨¡å¼
npm run build     # ç”Ÿäº§æ„å»º
```

### åŠ è½½åˆ°Edgeæµè§ˆå™¨
1. æ‰“å¼€ `edge://extensions/`
2. å¯ç”¨"å¼€å‘è€…æ¨¡å¼"
3. ç‚¹å‡»"åŠ è½½è§£å‹ç¼©çš„æ‰©å±•"
4. é€‰æ‹© `dist/` æ–‡ä»¶å¤¹

### å‘å¸ƒåˆ°Edge Store
1. æ‰“åŒ… `dist/` ä¸º `.zip`
2. æäº¤åˆ° [Microsoft Partner Center](https://partner.microsoft.com/)
3. ç­‰å¾…å®¡æ ¸é€šè¿‡

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2026-01-05
